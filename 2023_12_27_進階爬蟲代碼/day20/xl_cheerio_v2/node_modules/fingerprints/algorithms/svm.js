const Fingerprint = require('./base-fingerprint.js');

class SVM extends Fingerprint {
	generate (inParams, onDone) {
		const generateThread = this.spawn((inParams, onDone, progress) => {
			progress({progress_report_type: 0, report: {status: 1, info: 'Генерация отпечатка. Старт.'}});
			console.log('!!!!!!!!!!!!!!!!');
			if (inParams.subjects.folders === undefined || inParams.nosubjects.folders === undefined)
				throw new Error('Svm fingerprint generate thread: have not folders!');
			if (inParams.subjects.folders.length === 0 || inParams.nosubjects.folders.length === 0)
				throw new Error('Svm fingerprint generate thread: Folders paths is empty!');

			const path = require('path');
			const EventEmitter = require('events').EventEmitter;
			const initThreadsProcess = require(inParams.__dirname + '/../init-thread-env-args.js');
			initThreadsProcess(inParams);

			const SvmTrainerClass = require(path.join(inParams.__dirname, '/../trainers/svm-trainer.js'));
			let SvmTrainer = new SvmTrainerClass();
			let GenerationEventEmitter = new EventEmitter();

			let trainParams = {
				minWeight: inParams.options.threshold_weight,
				minLength: 4,
				category: inParams.subjects.folders,
				anticategory: inParams.nosubjects.folders,
				__dirname: inParams.__dirname,
				eventEmitter: GenerationEventEmitter
			};

			SvmTrainer.train(trainParams, (err, status) => {
				if (err)
					throw new Error('Svm fingerprint generate thread: Error on training! ' + err);
				return onDone({generateErrors: status.trainError});
			});

			GenerationEventEmitter.on('generation_report', (report) => {
				progress({progress_report_type: 0, report: report});
			});

			GenerationEventEmitter.on('log_report', (outStatus) => {
				progress({progress_report_type: 1, report: outStatus});
			});
		}, [], { execArgv: [] });
		generateThread
			.send(this.params)
			.on('progress', (information) => {
				switch (information.progress_report_type) {
					case 0:
						this.currentStatus = information.report;
						inParams.statusEmitter.emit('status', this.currentStatus);
						break;
					case 1:
						inParams.statusEmitter.emit('log', information.report);
						break;
				}
			})
			.on('message', (out) => {
				if (out.generateErrors === false)
					this.currentStatus = {status: 3, info: 'Генерация успешно выполнена'};
				else
					this.currentStatus = {status: 4, info: 'Генерация проведена с ошибкой'};
				inParams.statusEmitter.emit('status', this.currentStatus);
				generateThread.kill();
			})
			.on('error', (err) => {
				this.currentStatus = {status: 5, info: 'Генерация не выполнена'};
				inParams.statusEmitter.emit('status', this.currentStatus);
				return onDone(err);
			})
			.on('exit', () => onDone(null, {tempFolder: this.params.tempCatalog, log: this.params.log, currentStatus: this.currentStatus}));
	}
/*
	check (inParams, onDone) { // формат inParams - coincidence_rate - порог вхождения (от 1 до 100), path - путь к файлу, categoryPath - папка с отпечатком, statusEmitter - евент емиттер 
		let currentParams = Object.assign({}, this.params);
		currentParams.checkParams = inParams;
		let currentAnswer;

		const checkThread = this.spawn((inParams, onDone, progress) => {
			const path = require('path');
			const initThreadsProcess = require(inParams.__dirname + '/../init-thread-env-args.js');
			initThreadsProcess(inParams);

			const BayesTrainerClass = require(path.join(inParams.__dirname, '/../trainers/bayes-trainer.js'));
			let bayesTrainer = new BayesTrainerClass();

			progress({status: 2, info: 'Проверка файла ' + inParams.checkParams.path + ' по отпечатку'});
			bayesTrainer.load({pathToModel: inParams.checkParams.categoryPath}, (err) => {
				if (err)
					throw new Error('Bayes fingerprint check thread: Error on load model! ' + err);
				let currentExtractParams = Object.assign({}, bayesTrainer.baseExtractParams);
				currentExtractParams.in_path = inParams.checkParams.path;
				currentExtractParams.out_path = inParams.checkParams.path + '.txt';

				bayesTrainer.prepareTextContent(currentExtractParams, (err, outData) => {
					if (err)
						throw new Error('Bayes fingerprint check thread: Error on load content for check! ' + err);
					let content = outData.data.toString();
					bayesTrainer.check({content: content, output_type: 1}, (err, result) => {
						if (err)
							throw new Error('Bayes fingerprint check thread: Error on check! ' + err);
						let answer = {
							status: 3,
							Check_Result: {
								IsDuplicate: false}
						};

						if (result.probability < inParams.coincidence_rate / 100)
							return onDone(answer);
						let answerElements = {Algorithm: 'Bayes',
							result: result,
							answer: answer,
							categoryPath: inParams.checkParams.categoryPath};
						return onDone(bayesTrainer.formTrueCheckAnswer(answerElements));
					});
				});
			});
		}, [], { execArgv: [] });
		checkThread
			.send(currentParams)
			.on('progress', (currentStatus) => {
				this.currentStatus = currentStatus;
				inParams.statusEmitter.emit('status', this.currentStatus);
			})
			.on('message', (answer) => {
				currentAnswer = answer;
				inParams.statusEmitter.emit('status', answer);
				checkThread.kill();
			})
			.on('error', (err) => {
				this.currentStatus = {status: 3, info: 'Проверка закончилась с ошибкой'};
				inParams.statusEmitter.emit('status', this.currentStatus);
				return onDone(err);
			})
			.on('exit', () => {
				this.currentStatus = {status: 3, info: 'Генерация успешно выполнена'};
				return onDone(null, currentAnswer);
			});
	}
	*/
}
module.exports.SVM = SVM;
