const fs = require('fs');
const path = require('path');
const async = require('async');
const crc32 = require('crc-32');
const encoding = require('encoding');
const Trainer = require(path.join(__dirname, 'base-trainer.js'));
const textUtils = require(path.join(__dirname, '/../../text-utils'));
const ProblemSVM = require(path.join(__dirname, './svm-additional/svm-problem.js'));
const ModelSVM = require(path.join(__dirname, './svm-additional/svm-model.js'));

class SvmTrainer extends Trainer {
	train (inParams, onDone) {
		this.wordsDictionary = [];
		this.vectors = [];
		let trainError = false;
		this._getCategoryAndAnticategoryFilesPaths(inParams, (err, result) => {
			if (err)
				return onDone(err, {trainError: true});
			trainError = result.trainError;
			if (result.trainFilesPaths.length === 0)
				return onDone(err, {trainError: true});
			let problemSVM = new ProblemSVM();
			async.forEachSeries(result.trainFilesPaths, (trainFile, trainFileDone) => {
				// let startTime = new Date();
				let extractParams = Object.assign({}, this.baseExtractParams);
				extractParams.in_path = trainFile.path;
				extractParams.out_path = trainFile.path + '.txt';
				inParams.eventEmitter.emit('generation_report', {status: 1,
					info: /* zres:z_cs_text_component_extracted_from_file_1 */'Из файла ' + extractParams.in_path + ' извлекается текстовая составляющая.'/* /zres */});
				this.prepareTextContent(extractParams, (err, extractResult) => {
					console.log(err);
					if (err) {
						trainError = true;
						if (err.type === 'internal')
							inParams.eventEmitter.emit('log_report', {message: err.message});
						return trainFileDone();
					}
					let tokenizeParams = {
						data: extractResult.data,
						transformToLower: true,
						deleteDuplicate: false,
						minLength: inParams.minLength,
						based_on: 0
					};
					textUtils.tokenize(tokenizeParams, (err, rawSplittedElements) => {
						if (err) {
							trainError = true;
							return trainFileDone();
						}
						if (rawSplittedElements.length === 0) {
							trainError = true;
							let errMessage = /* zres:z_cs_error_processing_file_empty */'\r\nОшибка при обработке файла ' + extractParams.in_path + ' - пустой файл. '/* /zres */;
							inParams.eventEmitter.emit('log_report', {message: errMessage});
							return trainFileDone();
						}
						let currentVector = [];
						rawSplittedElements.forEach((element) => {
							let processedElement = textUtils.stemmer.stemmSync({data: element});
							if (processedElement.length >= 4) { // поправить на инпут
								processedElement = encoding.convert(processedElement, 'utf16le').toString();
								let currentCrc32 = crc32.str(processedElement);
								this.wordsDictionary.push(currentCrc32);
								currentVector.push({crc: currentCrc32, value: 1});
							}
						});
						problemSVM.l++;
						this.vectors.push({vector: currentVector, category: trainFile.category});
						return trainFileDone();
					});
				});
			},
			(err) => {
				if (err)
					return onDone(err, {trainError: true});
				if (this.wordsDictionary.length === 0)
					return onDone(err, {trainError: true});
				let used = {};
				let fixedWordsDictionary = this.wordsDictionary.filter((element) => {
					return element in used ? 0 : (used[element] = 1);
				});
				for (let i = 0; i < fixedWordsDictionary.length; i++)
					fixedWordsDictionary[i] = {first: fixedWordsDictionary[i], second: i};
				let xSpace = [];
				this.vectors.forEach((currentVector) => {
					currentVector.vector.forEach((currentElement) => {
						let founded = {};
						fixedWordsDictionary.some((element) => {
							if (currentElement.crc === element.first) {
								Object.assign(founded, element);
								return true;
							} else {
								return false;
							}
						});
						if (founded !== undefined)
							xSpace.push({coord: founded.second, value: 1});
					});
					xSpace.push({coord: -1, value: 0});
					problemSVM.y.push(currentVector.category);
				});
				let tempArr = [];
				for (let i = 0; i < xSpace.length; i++) {
					if (xSpace[i].coord !== -1) {
						tempArr.push(xSpace[i].coord);
					} else {
						tempArr.sort((a, b) => {
							return a - b;
						});
						let min = tempArr[0];
						tempArr = tempArr.map((currentTemp) => {
							return ({coord: currentTemp, value: 1});
						});
						tempArr[tempArr.length] = {coord: -1, value: 1};
						problemSVM.x.push({coord: min, value: 1, internal: tempArr});
						tempArr = [];
					}
				}
				this.wordsDictionary = fixedWordsDictionary;
				let svmParams = {
					svl_type: 'C_SVC',
					kernel_type: 'RBF',
					degree: 3,
					gamma: 1 / this.wordsDictionary.length,
					coef0: 0,
					nu: 0.5,
					cache_size: 100,
					C: 1,
					eps: 1e-3,
					p: 0.1,
					shrinking: true,
					probability: true,
					num_weight: 0,
					weight_label: [],
					weight: []
				};
				/*
				for (let i = 0; i < this.vectors.length; i++) {
					console.log('x coord = ' + problemSVM.x[i].coord);
					console.log('y = ' + problemSVM.y[i]);
				}
                */
				this.modelSVM = new ModelSVM(svmParams);
				this.modelSVM.train({svmProblem: problemSVM});
				console.log('TRAINEDD!!!');
				console.log(JSON.stringify(this.modelSVM));
				this.DEL = trainError;
			});
		});
	}

	save (inParams, onDone) {

	}

	_saveDictionary (inParams, onDone) {
		let writeStream = fs.createWriteStream(inParams.dictionarySavePath, {flags: 'a'});
		async.forEachSeries(this.wordsDictionary, (current, currentDone) => {
			return writeStream.write(this.prepareDataFormatToSave({data: current.first, type: 'int'}), (err) => {
				if (err)
					return currentDone(err);
				return writeStream.write(this.prepareDataFormatToSave({data: current.second, type: 'int'}), (err) => currentDone(err));
			});
		},
		(err) => {
			if (err)
				return onDone(err);
			writeStream.end();
			return onDone();
		});
	}

	_getCategoryAndAnticategoryFilesPaths (inParams, onDone) {
		let categoriesFiles = [];
		let anticategoriesFiles = [];
		let trainFilesPaths = [];
		let methodError = false;
		async.forEach(inParams.category, (currentCategory, currentCategoryDone) => {
			this.getAvalibleFilePathsFromFolder({folder: currentCategory.value}, (err, outData) => {
				if (err)
					return currentCategoryDone(err);
				if (outData.internalError) {
					let message = /* zres:z_cs_error_calc_path */'Ошибка при вычислении путей'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: message});
					methodError = true;
				} else {
					categoriesFiles = categoriesFiles.concat(outData.filePaths);
				}
				return currentCategoryDone();
			});
		},
		(err) => {
			if (err)
				return onDone(err);
			async.forEach(inParams.anticategory, (currentAntiategory, currentAntiategoryDone) => {
				this.getAvalibleFilePathsFromFolder({folder: currentAntiategory.value}, (err, outData) => {
					if (err)
						return currentAntiategoryDone(err);
					if (outData.internalError) {
						let message = /* zres:z_cs_error_calc_path */'Ошибка при вычислении путей'/* /zres */;
						inParams.eventEmitter.emit('log_report', {message: message});
						methodError = true;
					} else {
						anticategoriesFiles = anticategoriesFiles.concat(outData.filePaths);
					}
					return currentAntiategoryDone();
				});
			},
			(err) => {
				categoriesFiles.forEach((current) => {
					trainFilesPaths.push({path: current, category: 1});
				});
				anticategoriesFiles.forEach((current) => {
					trainFilesPaths.push({path: current, category: 2});
				});
				return onDone(err, {trainError: methodError, trainFilesPaths: trainFilesPaths});
			});
		});
	}
}
module.exports = SvmTrainer;
