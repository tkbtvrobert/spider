const fs = require('fs');
const path = require('path');
const async = require('async');
const crc32 = require('crc-32');
const xml2js = require('xml2js');
const encoding = require('encoding');
const builder = require('xmlbuilder');
const Trainer = require(path.join(__dirname, 'base-trainer.js'));
const textUtils = require(path.join(__dirname, '/../../text-utils'));

class ShinglesTrainer extends Trainer {
	// сегмент генерации. старт
	train (inParams, onDone) {
		let trainError = false;
		let trainFilesPaths = [];
		this.FileNamesMapData = [];
		async.forEach(inParams.folders, (currentFolder, currentFolderDone) => {
			this.getAvalibleFilePathsFromFolder({folder: currentFolder.value}, (err, outData) => {
				if (err)
					return currentFolderDone(err);
				if (outData.internalError) {
					let message = /* zres:z_cs_error_calc_path */'Ошибка при вычислении путей'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: message});
					trainError = true;
				} else {
					trainFilesPaths = trainFilesPaths.concat(outData.filePaths);
				}
				return currentFolderDone();
			});
		},
		(err) => {
			if (err)
				return onDone(err, {trainError: true});
			if (trainFilesPaths.length === 0) {
				let message = /* zres:z_cs_not_file_for_generation */'нет файлов для генерации'/* /zres */;
				inParams.eventEmitter.emit('log_report', {message: message});
				return onDone('no files', {trainError: true});
			}
			inParams.eventEmitter.emit('generation_report', {status: 1,
				info: /* zres:z_cs_find_files */'Обнаружено ' + trainFilesPaths.length + 'файлов'/* /zres */});
			async.forEachSeries(trainFilesPaths, (currentTrainFilePath, currentTrainFileDone) => {
				let startTime = new Date();
				let extractParams = Object.assign({}, this.baseExtractParams);
				extractParams.in_path = currentTrainFilePath;
				extractParams.out_path = currentTrainFilePath + '.txt';
				inParams.eventEmitter.emit('generation_report', {status: 1,
					info: /* zres:z_cs_text_component_extracted_from_file_1 */'Из файла ' + extractParams.in_path + ' извлекается текстовая составляющая.'/* /zres */});
				this.prepareTextContent(extractParams, (err, result) => {
					if (err) {
						trainError = true;
						if (err.type === 'internal')
							inParams.eventEmitter.emit('log_report', {message: err.message});
						return currentTrainFileDone();
					}
					this.getDataByStream({filepath: currentTrainFilePath}, (err, binaryFileData) => {
						if (err)
							trainError = true;
						let currentFileData = {
							originalName: currentTrainFilePath,
							size: binaryFileData.length,
							crc32: crc32.buf(binaryFileData),
							time: this._getTime({date: startTime})
						};
						let tokenizeParams = {
							data: result.data,
							transformToLower: true,
							deleteDuplicate: false,
							minLength: inParams.minLength,
							based_on: inParams.based_on
						};
						textUtils.tokenize(tokenizeParams, (err, rawSplittedElements) => {
							if (err) {
								trainError = true;
								return currentTrainFileDone();
							}
							if (rawSplittedElements.length === 0) {
								trainError = true;
								let errMessage = /* zres:z_cs_error_processing_file_empty */'\r\nОшибка при обработке файла ' + extractParams.in_path + ' - пустой файл. '/* /zres */;
								inParams.eventEmitter.emit('log_report', {message: errMessage});
								return currentTrainFileDone();
							}
							let crc32Arr = [];
							rawSplittedElements.forEach((element) => {
								let processedElement = textUtils.stemmer.stemmSync({data: element});
								processedElement = encoding.convert(processedElement, 'utf16le').toString();
								crc32Arr.push(crc32.str(processedElement));
							});
							this.processed++;
							inParams.eventEmitter.emit('generation_report', {status: 1,
								info: /* zres:z_cs_file_process */'Файл ' + extractParams.in_path + ' обработан. Обработано ' + this.processed + ' из ' + trainFilesPaths.length/* /zres */});
							let generatedName = this._generateNameToSave({fileCount: this.processed,
								based_on: inParams.based_on,
								minLengthWord: inParams.minLength
							});
							currentFileData.source = generatedName;
							this.FileNamesMapData.push(currentFileData);
							if (generatedName === undefined) {
								trainError = true;
								return currentTrainFileDone();
							}
							let currentFileSaveParams = {
								pathToSave: path.join(inParams.pathToCategoryCatalog, generatedName),
								data: crc32Arr
							};
							this.save(currentFileSaveParams, (err) => {
								if (err)
									trainError = true;
								let finishTime = new Date();
								var deltaTime = this._getDeltaTime({start: startTime, finish: finishTime});
								let message = /* zres:z_cs_file_added_name */'\r\nФайл ' + currentTrainFilePath + ' добавлен. Имя: ' + generatedName + '. Затраченное время: '/* /zres */ + deltaTime;
								inParams.eventEmitter.emit('log_report', {message: message});
								return currentTrainFileDone();
							});
						});
					});
				});
			},
			(err) => {
				if (err) {
					let errMessage = /* zres:z_cs_generation_error1 */'\r\nОшибка при генерации'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: errMessage});
				} else {
					let message = /* zres:z_cs_generation_and_saving_successful */'\r\nГенерация и сохранения успешно выполнены.'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: message});
					inParams.eventEmitter.emit('generation_report', {status: 1,
						info: /* zres:z_cs_successfully_saved_model */'Модель успешно сохранена'/* /zres */});
				}
				this._saveFileNameMap({path: inParams.pathToCategoryCatalog}, (err) => {
					if (err) {
						let errMessage = /* zres:z_cs_error_save_filemap */'\r\nОшибка при сохранении FileMap'/* /zres */;
						inParams.eventEmitter.emit('log_report', {message: errMessage});
						trainError = true;
					}
					return onDone(err, {trainError: trainError});
				});
			});
		});
	}

	_getDeltaTime (inParams) {
		let deltaHours = this._fixDateTimeFormat({time: inParams.finish.getHours() - inParams.start.getHours()});
		let deltaMinutes = this._fixDateTimeFormat({time: inParams.finish.getMinutes() - inParams.start.getMinutes()});
		let deltaSeconds = this._fixDateTimeFormat({time: inParams.finish.getSeconds() - inParams.start.getSeconds()});
		return deltaHours + ':' + deltaMinutes + ':' + deltaSeconds;
	}

	_getTime (inParams) {
		let hour = this._fixDateTimeFormat({time: inParams.date.getHours()});
		let min = this._fixDateTimeFormat({time: inParams.date.getMinutes()});
		let sec = this._fixDateTimeFormat({time: inParams.date.getSeconds()});
		let year = inParams.date.getFullYear();
		let month = this._fixDateTimeFormat({time: inParams.date.getMonth()});
		let day = this._fixDateTimeFormat({time: inParams.date.getDate()});
		return day + '.' + month + '.' + year + '; ' + hour + ':' + min + ':' + sec;
	}

	_fixDateTimeFormat (inParams) {
		return inParams.time > 9 ? inParams.time : '0' + inParams.time;
	}

	_saveFileNameMap (inParams, onDone) {
		let fileMapJson = {
			settings: {
				'@stoplist_CRCR32': '0x00000000',
				'@templates_CRC32': '0x00000000',
				'@stemming': 'yes',
				'@sentences': 'no',
				'@changeletters': 'no',
				'@use_train_ocr': 'no',
				'@use_train_img': 'no',
				'@min_word_length': '4'
			},
			file_names_map: {
				'@iteration_number': '1',
				file_names_map_item: []
			}
		};
		if (this.FileNamesMapData.length === 0)
			return onDone('Have not files map');
		this.FileNamesMapData.forEach((current) => {
			let parsedFilename = path.parse(current.originalName);
			let block = {
				'@source': current.source,
				'@original_name': parsedFilename.name + parsedFilename.ext,
				'@time': current.time,
				'@CRC32': current.crc32,
				'@size': current.size,
				'@iteration': '1'
			};
			fileMapJson.file_names_map.file_names_map_item.push(block);
		});
		let feed = builder.create(fileMapJson, { encoding: 'utf-8' });
		fs.writeFile(path.join(inParams.path, 'FileNamesMap11.xml'), feed.end({pretty: true}), (err) => onDone(err));
	}
	_generateNameToSave (inParams) {
		let name;
		try {
			name = inParams.fileCount.toString();
			name += inParams.based_on === 1 ? '$' : '_';
			name += inParams.minLengthWord.toString();
			name += ',1,0.zfpwors';
		} catch (err) {
			return undefined;
		}
		return name;
	}

	save (inParams, onDone) {
		let writeStream = fs.createWriteStream(inParams.pathToSave, {flags: 'a'});
		async.forEachSeries(inParams.data, (currentData, currentDataDone) => {
			writeStream.write(this.prepareDataFormatToSave({data: currentData, type: 'int'}), (err) => currentDataDone(err));
		}, (err) => onDone(err));
	}
	// сегмент генерации. конец
	// сегмент загрузки. старт 
	load (inParams, onDone) {
		this.preCheckingInfo = [];
		this.internalShinglesObjects = [];
		this.shinlesLengthVariants = [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
		let shingleObjectTemplate = {categoryShinglesByLength: [], categoryWordsCrc: [], binary: null};
		fs.readdir(inParams.categoryPath, (err, files) => {
			if (err)
				return onDone('Problems with reading directory');
			let zfpworsFiles = files.filter((file) => {
				if (file.includes('.zfpwors'))
					return file;
			});
			if (zfpworsFiles.length === 0)
				return onDone('No ZFPWORS file');
			let specSymbol = zfpworsFiles[0].includes('$') ? '$' : '_';
			this.contentPrepareProcessor = specSymbol === '$' ? this._sentencesProcessor : this._wordsProcessor;
			this.checkTokenizeParams = {
				transformToLower: true,
				deleteDuplicate: false
			};
			this.checkTokenizeParams.based_on = this.contentPrepareProcessor === this._sentencesProcessor ? 1 : 0;
			this.checkTokenizeParams.minLength = zfpworsFiles[0].split(specSymbol)[1][0];
			async.forEach(zfpworsFiles, (currentZfp, currentZfpDone) => {
				this.getDataByStream({filepath: path.join(inParams.categoryPath, currentZfp)}, (err, data) => {
					if (err)
						return currentZfpDone(err);
					let shingleObject = Object.assign({}, shingleObjectTemplate);
					shingleObject.binary = data;
					this.internalShinglesObjects.push(shingleObject);
					return currentZfpDone();
				});
			},
			(err) => {
				if (err)
					return onDone(err);
				if (this.internalShinglesObjects.length === 0)
					return onDone('No shingle objects!');
				async.forEachSeries(this.internalShinglesObjects, (currentObject, currentObjectDone) => {
					this._readWordsCrcByZpfworsBinary({binary: currentObject.binary}, (err, categoryWordsCrc) => {
						if (err) {
							console.log('WARNING! can not read crc32 words!');
							return currentObjectDone('WARNING! can not read crc32 words!');
						}
						currentObject.categoryWordsCrc = categoryWordsCrc;
						this._sliceShinglesByReadedCrc({categoryWordsCrc: categoryWordsCrc}, (err, categoryShinglesByLength) => {
							if (err) {
								console.log('WARNING! cant slice shingles!');
								return currentObjectDone('WARNING! cant slice shingles!');
							}
							currentObject.categoryShinglesByLength = categoryShinglesByLength;
							return currentObjectDone();
						});
					});
				},
				(err) => {
					if (err)
						this.isBroken = true;
					this.getDataByStream({filepath: path.join(inParams.categoryPath, 'FileNamesMap11.xml')}, (err, data) => {
						if (err)
							this.isBroken = true;
						let parser = new xml2js.Parser();
						let neededSection = data.slice(data.toString().indexOf('<file_names_map'), data.length);
						parser.parseString(neededSection.toString(), (err, result) => {
							if (err)
								return onDone(err);
							result.file_names_map.file_names_map_item.forEach((currentBlock) => {
								this.preCheckingInfo.push(currentBlock.$);
							});
							return onDone();
						});
					});
				});
			});
		});
	}

	_readWordsCrcByZpfworsBinary (inParams, onDone) {
		let offset = 0;
		let categoryWordsCrc = [];
		while (offset < inParams.binary.length) {
			categoryWordsCrc.push(inParams.binary.readInt32LE(offset, offset + 4));
			offset += 4;
		}
		if (categoryWordsCrc.length === 0)
			return onDone('Shingles not found');
		return onDone(null, categoryWordsCrc);
	}

	_sliceShinglesByReadedCrc (inParams, onDone) {
		let shingleTemplate = {length: 0, shingles: []};
		let categoryShinglesByLength = [];
		async.forEach(this.shinlesLengthVariants, (shingleLength, shingleLengthDone) => {
			let currentVariantOfShingles = Object.assign({}, shingleTemplate);
			currentVariantOfShingles.length = shingleLength;
			currentVariantOfShingles.shingles = this._getCrcOfPreparedShingles({elementsCrc: inParams.categoryWordsCrc, shingleLength: shingleLength, from: 0});
			categoryShinglesByLength.push(currentVariantOfShingles);
			return shingleLengthDone();
		},
		(err) => {
			if (err)
				return onDone(err);
			if (categoryShinglesByLength.length === 0)
				return onDone('Cant get shingles by length');
			return onDone(null, categoryShinglesByLength);
		});
	}

	_getCrcOfPreparedShingles (inParams) {
		let filteredCrc = [];
		if (inParams.shingleLength === 1) {
			let used = {};
			filteredCrc = inParams.elementsCrc.filter((obj) => {
				if (inParams.from === 0)
					return obj in used ? 0 : (used[obj] = 1);
				else
					return obj.crc in used ? 0 : (used[obj.crc] = 1);
			});
			return (filteredCrc);
		}
		let shingles = [];
		let readyShinglesObjects = [];
		let offset = inParams.from === 1 ? 1 : Math.ceil(inParams.shingleLength / 2);
		let processed = 0;
		while (processed + inParams.shingleLength <= inParams.elementsCrc.length) {
			let currentShingle = inParams.elementsCrc.slice(processed, processed + inParams.shingleLength);
			processed += offset;
			shingles.push(currentShingle);
		}
		if (inParams.from === 0) {
			readyShinglesObjects = shingles.map((currentShingle) => {
				return crc32.buf(Buffer.from(currentShingle));
			});
		} else {
			shingles.forEach((currentShingle) => {
				let currentSrcArray = [];
				let currentElements = '';
				currentShingle.forEach((shingle) => {
					currentSrcArray.push(shingle.crc);
					currentElements += shingle.element + ' ';
				});
				let commonCrc = crc32.buf(Buffer.from(currentSrcArray));
				readyShinglesObjects.push({element: currentElements, crc: commonCrc});
			});
		}
		let used = {};
		filteredCrc = readyShinglesObjects.filter((obj) => {
			if (inParams.from === 0)
				return obj in used ? 0 : (used[obj] = 1);
			else
				return obj.crc in used ? 0 : (used[obj.crc] = 1);
		});
		if (filteredCrc.length === 0)
			return undefined;
		return (filteredCrc);
	}

	pepareContentFileInfo (inParams, onDone) {
		this.getDataByStream(inParams, (err, binaryFileData) => {
			if (err)
				return onDone(err);
			let result = {
				size: binaryFileData.length,
				crc32: crc32.buf(binaryFileData)
			};
			return onDone(null, result);
		});
	}
	// сегмент загрузки. конец
	// сегмент проверки. старт 
	check (inParams, onDone) { // если в inParams.output_type: 1, то вернутся веротяность и слова-совпадения, в противном случае только вероятность
		if (this.isBroken)
			return onDone(null, {probability: 0});
		if (this.contentPrepareProcessor === undefined)
			return onDone(null, {probability: 0});
		let crc32answer;
		this.preCheckingInfo.some((currentCheckInfo) => {
			if (parseInt(currentCheckInfo.CRC32) === inParams.crc32 && parseInt(currentCheckInfo.size) === inParams.size) {
				crc32answer = {
					status: 3,
					Check_Result: {
						IsDuplicate: true,
						Probability: 100,
						Algorithm: 'File CRC32',
						DuplicateFileName: currentCheckInfo.original_name
					}
				};
				let logString = 'size = ' + inParams.size + ' and crc32 = ' + inParams.crc32 + ' are equal to original file ' + currentCheckInfo.original_name;
				let base64logString = Buffer.from(logString).toString('base64');
				crc32answer.Log = base64logString;
				return true;
			}
		});
		if (crc32answer !== undefined)
			return onDone(null, {preAnswer: crc32answer});
		this.checkTokenizeParams.data = inParams.content;
		textUtils.tokenize(this.checkTokenizeParams, (err, rawSplittedElements) => {
			if (err)
				return onDone(err);
			this.contentPrepareProcessor({rawSplittedElements: rawSplittedElements}, (err, result) => {
				if (err)
					return onDone(err);
				if (result.status === 'not enough elements')
					return onDone(null, {probability: 0});
				let shingleLength = this._getShingleLength({numberOfElements: result.elementsCrc.length});
				let crcOfPreparedShingles = this._getCrcOfPreparedShingles({elementsCrc: result.elementsCrc, shingleLength: shingleLength, from: 1});
				let reserveCrcOfPreparedShingles = this._getCrcOfPreparedShingles({elementsCrc: result.elementsCrc, shingleLength: 1, from: 1});
				let tempFoundedResult;
				async.detectSeries(this.internalShinglesObjects, (currentInternalObject, currentInternalObjectDone) => {
					this._compareShingles({shingleLength: shingleLength, contentShinglesCrc: crcOfPreparedShingles, reserve: reserveCrcOfPreparedShingles, object: currentInternalObject}, (err, result) => {
						if (err)
							return currentInternalObjectDone(err);
						if (result.probability * 100 >= inParams.threshold) {
							tempFoundedResult = {probability: result.probability, foundedWords: result.foundedElements};
							return currentInternalObjectDone(null, true);
						} else {
							return currentInternalObjectDone(null, false);
						}
					});
				},
				(err, element) => {
					if (err)
						return onDone(err);
					if (element === undefined)
						return onDone(null, {probability: 0, foundedWords: []});
					else
						return onDone(null, tempFoundedResult);
				});
			});
		});
	}

	_getShingleLength (inParams) {
		let length = Math.log(inParams.numberOfElements);
		if (length < 1)
			return 1;
		for (let i = this.shinlesLengthVariants.length - 1; i >= 0; i--) {
			if (this.shinlesLengthVariants[i] < length)
				return this.shinlesLengthVariants[i];
		}
		return 1;
	}

	_wordsProcessor (inParams, onDone) {
		if (inParams.rawSplittedElements.length <= 20)
			return onDone(null, {status: 'not enough elements'});
		let elementsCrc = [];
		inParams.rawSplittedElements.forEach((element) => {
			let fixedWord = this._getPreparedWord({word: element});
			if (fixedWord !== undefined)
				elementsCrc.push({element: element, crc: crc32.str(fixedWord)});
		});
		return onDone(null, ({status: 'done', elementsCrc: elementsCrc}));
	}

	_sentencesProcessor (inParams, onDone) {
		if (inParams.rawSplittedElements.length <= 10)
			return onDone(null, {status: 'not enough elements'});
		let elementsCrc = [];
		async.forEachSeries(inParams.rawSplittedElements, (currentRawSplittedElement, currentRawSplittedElementDone) => {
			this._getPreparedSentence({sentense: currentRawSplittedElement}, (err, preparedElement) => {
				if (err)
					return currentRawSplittedElementDone(err);
				if (preparedElement !== undefined)
					elementsCrc.push({element: preparedElement, crc: crc32.str(preparedElement)});
				return currentRawSplittedElementDone();
			});
		},
		(err) => {
			if (err)
				return onDone(err);
			return onDone(null, ({status: 'done', elementsCrc: elementsCrc}));
		});
	}

	_getPreparedWord (inParams) {
		let currentWord = textUtils.stemmer.stemmSync({data: inParams.word});
		currentWord = encoding.convert(currentWord, 'utf16le').toString();
		return currentWord;
	}

	_getPreparedSentence (inParams, onDone) {
		let currentTokenizeParams = Object.assign({}, this.checkTokenizeParams);
		currentTokenizeParams.based_on = 0;
		currentTokenizeParams.data = inParams.sentense;
		textUtils.tokenize(this.checkTokenizeParams, (err, tokenizedSenteseWords) => {
			if (err)
				return onDone(err);
			let filteredSenteseWords = tokenizedSenteseWords.map((word) => {
				return (this._getPreparedWord({word: word}));
			});
			if (filteredSenteseWords.length === 0)
				return onDone();
			let resultSentenseString = '';
			filteredSenteseWords.forEach((word) => {
				resultSentenseString += (word + ' ');
			});
			return onDone(null, resultSentenseString);
		});
	}

	_compareShingles (inParams, onDone) {
		let numberOfEntrance = 0;
		let foundedElements = [];
		let contentShinglesCrc = inParams.contentShinglesCrc;
		let neededVartiantsOfCategoryShingles = this._getNeededShingleVariant(inParams);
		if (neededVartiantsOfCategoryShingles.shingles === undefined) {
			let rerollParams = Object.assign(inParams);
			inParams.shingleLength = 1;
			neededVartiantsOfCategoryShingles = this._getNeededShingleVariant(rerollParams);
			contentShinglesCrc = inParams.reserve;
		}
		contentShinglesCrc.forEach((contentShingle) => {
			neededVartiantsOfCategoryShingles.shingles.some((categoryShingle) => {
				if (contentShingle.crc === categoryShingle) {
					foundedElements.push(contentShingle.element);
					numberOfEntrance++;
					return true;
				}
			});
		});
		if (numberOfEntrance === 0)
			return onDone(null, {probability: 0, foundedElements: foundedElements});
		let minLength = (inParams.contentShinglesCrc.length < neededVartiantsOfCategoryShingles.shingles.length ? inParams.contentShinglesCrc.length : neededVartiantsOfCategoryShingles.shingles.length);
		let result = numberOfEntrance / minLength;
		return onDone(null, {probability: result, foundedElements: foundedElements});
	}

	_getNeededShingleVariant (inParams) {
		let neededVartiantsOfCategoryShingles = {};
		inParams.object.categoryShinglesByLength.some((shinglesVariant) => {
			if (shinglesVariant.length === inParams.shingleLength) {
				Object.assign(neededVartiantsOfCategoryShingles, shinglesVariant);
				return true;
			}
		});
		return neededVartiantsOfCategoryShingles;
	}
	// сегмент проверки. конец 
}
module.exports = ShinglesTrainer;
