const path = require('path');
const async = require('async');
const fs = require('fs');
const Trainer = require(path.join(__dirname, 'base-trainer.js'));
const textUtils = require(path.join(__dirname, '/../../text-utils'));
const equalsRegExp = require(path.join(__dirname, '../regexp_relations.json'));

class BayesTrainer extends Trainer {
	train (inParams, onDone) {
		let objectTemplate = {word: null, numberOfInterance: 1, probability: 0};
		let trainError = false;
		let trainFilesPaths = [];

		async.forEach(inParams.folders, (currentFolder, currentFolderDone) => {
			this.getAvalibleFilePathsFromFolder({folder: currentFolder.value}, (err, outData) => {
				if (err)
					return currentFolderDone(err);
				if (outData.internalError) {
					let message = /* zres:z_cs_error_calc_path */'Ошибка при вычислении путей'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: message});
					trainError = true;
				} else {
					trainFilesPaths = trainFilesPaths.concat(outData.filePaths);
				}
				return currentFolderDone();
			});
		},
		(err) => {
			if (err)
				return onDone(err, {trainError: true});
			if (trainFilesPaths.length === 0) {
				let message = /* zres:z_cs_not_file_for_generation */'нет файлов для генерации'/* /zres */;
				inParams.eventEmitter.emit('log_report', {message: message});
				return onDone('no files', {trainError: true});
			}
			inParams.eventEmitter.emit('generation_report', {status: 1,
				info: /* zres:z_cs_find_files */'Обнаружено ' + trainFilesPaths.length + 'файлов'/* /zres */});

			async.forEachSeries(trainFilesPaths, (currentTrainFilePath, currentTrainFileDone) => {
				let extractParams = Object.assign({}, this.baseExtractParams);
				extractParams.in_path = currentTrainFilePath;
				extractParams.out_path = currentTrainFilePath + '.txt';
				inParams.eventEmitter.emit('generation_report', {status: 1,
					info: /* zres:z_cs_text_component_extracted_from_file */'Из файла ' + extractParams.in_path + ' извлекается текстовая составляющая.'/* /zres */});
				this.prepareTextContent(extractParams, (err, result) => {
					if (err) {
						trainError = true;
						if (err.type === 'internal')
							inParams.eventEmitter.emit('log_report', {message: err.message});
						return currentTrainFileDone();
					}

					let tokenizeParams = {
						data: result.data,
						transformToLower: true,
						deleteDuplicate: true,
						minLength: inParams.minLength,
						based_on: 0
					};

					textUtils.tokenize(tokenizeParams, (err, rawSplittedElements) => {
						if (err) {
							trainError = true;
							return currentTrainFileDone();
						}
						if (rawSplittedElements.length === 0) {
							trainError = true;
							let errMessage = /* zres:z_cs_error_processing_file_empty */'\r\nОшибка при обработке файла ' + extractParams.in_path + ' - пустой файл. '/* /zres */;
							inParams.eventEmitter.emit('log_report', {message: errMessage});
							return currentTrainFileDone();
						}
						let numberOfOriginalWordsForLog = 0;
						rawSplittedElements.forEach((element) => {
							let processedElement = textUtils.stemmer.stemmSync({data: element});
							let elementIndex;

							this.trainedData.some((currentData, index) => {
								if (currentData.word === processedElement) {
									elementIndex = index;
									return true;
								}
								return false;
							});
							if (elementIndex !== undefined) {
								this.trainedData[elementIndex].numberOfInterance++;
							} else {
								numberOfOriginalWordsForLog++;
								let currentObject = Object.assign({}, objectTemplate);
								currentObject.word = processedElement;
								this.trainedData.push(currentObject);
							}
						});
						this.processed++;
						let message = /* zres:z_cs_file_process_successfully */'\r\nФайл ' + extractParams.in_path + ' успешно обработан, предварительно добавлено новых слов: ' + numberOfOriginalWordsForLog + '. '/* /zres */;
						inParams.eventEmitter.emit('log_report', {message: message});
						return currentTrainFileDone();
					});
				});
			},
			(err) => {
				if (err)
					return onDone(err, {trainError: true});
				let processedTrainedData = [];
				this.trainedData.forEach((currentObject) => {
					currentObject.probability = (currentObject.numberOfInterance / trainFilesPaths.length);
					if (currentObject.probability >= inParams.minWeight / 100)
						processedTrainedData.push({prob: currentObject.probability, word: currentObject.word, type: '1'});
				});

				if (processedTrainedData.length === 0) {
					let message = /* zres:z_cs_no_content_to_store_in_model */'\r\nНет контента для сохранения в модель'/* /zres */;
					inParams.eventEmitter.emit('log_report', {message: message});
					return onDone('no content', {trainError: true});
				}
				let message = /* zres:z_cs_words_to_store_in_model */'\r\nИз ' + this.trainedData.length + ' слов, порог допустимой вероятности (' + inParams.minWeight + ') преодолели: ' + processedTrainedData.length + '. Сохранение модели.'/* /zres */;
				inParams.eventEmitter.emit('log_report', {message: message});

				let saveParams = {
					trainedData: processedTrainedData,
					pathToSave: inParams.model
				};

				this.save(saveParams, (err) => {
					if (err) {
						let errMessage = /* zres:z_cs_byes_model_save_error */'\r\nОшибка при сохранении Байесовской модели'/* /zres */;
						inParams.eventEmitter.emit('log_report', {message: errMessage});
					} else {
						let message = /* zres:z_cs_gen_save_successfully */'\r\nГенерация и сохранение успешно выполнены.'/* /zres */;
						inParams.eventEmitter.emit('log_report', {message: message});
						inParams.eventEmitter.emit('generation_report', {status: 1,
							info: /* zres:z_cs_successfully_saved_model */'Модель успешно сохранена'/* /zres */});
					}
					return onDone(err, {trainError: trainError});
				});
			});
		});
	}

	save (inParams, onDone) {
		let writeStream = fs.createWriteStream(inParams.pathToSave, {flags: 'a'});
		async.waterfall([
			(callback) => {
				writeStream.write(this.prepareDataFormatToSave({data: '1', type: 'string'}), (err) => callback(err));
			},
			(callback) => {
				writeStream.write(this.prepareDataFormatToSave({data: inParams.trainedData.length, type: 'int'}), (err) => callback(err));
			},
			(callback) => {
				async.forEachSeries(inParams.trainedData, (currentData, currentDataDone) => {
					let wordBuffer = this.prepareDataFormatToSave({data: currentData.word, type: 'string'});
					async.waterfall([
						(inLoopCallback) => {
							writeStream.write(this.prepareDataFormatToSave({data: wordBuffer.length, type: 'int'}), (err) => inLoopCallback(err));
						},
						(inLoopCallback) => {
							writeStream.write(wordBuffer, (err) => inLoopCallback(err));
						},
						(inLoopCallback) => {
							writeStream.write(this.prepareDataFormatToSave({data: currentData.type, type: 'string'}), (err) => inLoopCallback(err));
						},
						(inLoopCallback) => {
							writeStream.write(this.prepareDataFormatToSave({data: currentData.prob, type: 'float'}), (err) => inLoopCallback(err));
						}
					],
					(err) => currentDataDone(err));
				}, (err) => callback(err));
			}],
		(err) => {
			if (err)
				return onDone(err);
			writeStream.end();
			return onDone();
		});
	}

	load (inParams, onDone) {
		this.brokenForCheck = false;
		this.fingerprintEssence = {bayesMap: []};
		let regularPattern = /[@#!^?*]/ig;

		this.getDataByStream({filepath: path.join(inParams.pathToModel, 'dict.bayes')}, (err, data) => {
			if (err) {
				// if ENOENT
				return onDone(err);
			}
			let offset = 6;
			while (offset < data.length) {
				let wordLength = data.readInt32LE(offset, offset + 4);
				offset += 4;
				let itselfWord = data.toString('utf16le', offset, offset + wordLength); // .toLowerCase();
				offset += wordLength;
				let probability = data.readFloatLE(offset + 2, offset + 6);
				offset += 6;

				let loopResult;
				let regExpWord = itselfWord;
				while ((loopResult = regularPattern.exec(itselfWord)))
					regExpWord = regExpWord.replace(itselfWord.charAt(loopResult.index), equalsRegExp[loopResult[0]]);

				let isOkay = true;
				try {
					regExpWord = new RegExp(regExpWord, 'gi');
				} catch (err) {
					isOkay = false;
					console.log('WARNING! There is error with creating RegExp from source ' + regExpWord);
				}
				if (isOkay)
					this.fingerprintEssence.bayesMap.push({word: regExpWord, prob: probability});
			}
			if (this.fingerprintEssence.bayesMap.length === 0) {
				console.log('WARNING! Bayes Dictionary is empty!');
				this.brokenForCheck = true;
			}
			return onDone();
		});
	}

	check (inParams, onDone) { // если в inParams.output_type: 1, то вернутся веротяность и слова-совпадения, в противном случае только вероятность
		if (this.brokenForCheck)
			return onDone(null, {probability: 0, foundedWords: []});
		let preparedContent = inParams.content;
		let probabilityArr = [];
		let foundedWords = [];
		this.fingerprintEssence.bayesMap.forEach((bayesMapObject) => {
			if (inParams.output_type === 1) {
				let result = bayesMapObject.word.exec(preparedContent);
				if (result !== null) {
					probabilityArr.push(bayesMapObject.prob);
					foundedWords.push(preparedContent.substr(result.index).split(/[^-а-яёa-z0-9]+/ig)[0]);
				}
			} else {
				if (bayesMapObject.word.test(preparedContent))
					probabilityArr.push(bayesMapObject.prob);
			}
		});

		if (probabilityArr.length === 0)
			return onDone(null, {probability: 0, foundedWords: foundedWords});

		if (probabilityArr.length === 1)
			return onDone(null, {probability: probabilityArr[0], foundedWords: foundedWords});

		let finalProbability;
		for (var j = 0; j < probabilityArr.length - 1; j++) {
			if (finalProbability === undefined)
				finalProbability = (probabilityArr[j] + probabilityArr[j + 1]) - (probabilityArr[j] * probabilityArr[j + 1]);
			else
				finalProbability = (finalProbability + probabilityArr[j + 1]) - (finalProbability * probabilityArr[j + 1]);
		}

		if (finalProbability === undefined)
			return onDone(null, {probability: 0, foundedWords: foundedWords});
		return onDone(null, {probability: finalProbability, foundedWords: foundedWords});
	}
}
module.exports = BayesTrainer;
