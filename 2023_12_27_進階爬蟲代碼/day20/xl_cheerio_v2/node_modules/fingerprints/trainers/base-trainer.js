const fs = require('fs');
const async = require('async');
const path = require('path');
const extractor = require(path.join(__dirname, '/../../extractor'));

class Trainer {
	constructor () {
		this.trainedData = [];
		this.processed = 0;
		this.baseExtractParams = {
			in_type: 0,
			in_path: null,
			out_path: null,
			delete_in: false,
			bExtractHiddenText: false
		};
	}

	train (inParams, onDone) {
		return onDone();
	}

	save (inParams, onDone) {
		return onDone();
	}

	load (inParams, onDone) {
		return onDone();
	}

	check (inParams, onDone) {
		return onDone();
	}

	unlinkFile (inParams, onDone) {
		fs.unlink(inParams.filepath, (err) => onDone(err));
	}

	getDataByStream (inParams, onDone) {
		let readStream = fs.createReadStream(inParams.filepath);
		let chunks = [];

		readStream.on('error', err => {
			return onDone(err);
		});

		readStream.on('data', chunk => {
			chunks.push(chunk);
		});

		readStream.on('close', () => {
			return onDone(null, Buffer.concat(chunks));
		});
	}

	getAvalibleFilePathsFromFolder (inParams, onDone) {
		let filePaths = [];
		fs.readdir(inParams.folder, (err, items) => {
			if (err)
				return onDone(null, {internalError: true, filePaths: filePaths});
			async.forEach(items, (currentItem, currentItemDone) => {
				let currentPath = path.join(inParams.folder, currentItem);
				fs.lstat(currentPath, (err, stats) => {
					if (err)
						return currentItemDone();
					if (stats.isDirectory()) {
						this.getAvalibleFilePathsFromFolder({folder: currentPath}, (err, outData) => {
							if (err)
								return currentItemDone();
							filePaths = filePaths.concat(outData.filePaths);
							return currentItemDone();
						});
					} else {
						filePaths.push(currentPath);
						return currentItemDone();
					}
				});
			},
			(err) => onDone(null, {internalError: err, filePaths: filePaths}));
		});
	}

	prepareTextContent (inParams, onDone) {
		async.waterfall([
			(callback) => {
				extractor.get_text_component(inParams, (err, outFilePath) => {
					if (err) {
						let error = {type: 'internal', message: /* zres:z_cs_error_retrieving_text_from_file */'\r\nОшибка при извлечении текста из файла '/* /zres */ + inParams.in_path + '. '};
						return callback(error);
					}
					return callback(null, {outFilePath: outFilePath});
				});
			},
			(params, callback) => {
				this.getDataByStream({filepath: params.outFilePath}, (err, data) => {
					if (err) {
						let error = {type: 'critical', message: err};
						return callback(error);
					}
					params.data = data;
					return callback(null, params);
				});
			},
			(params, callback) => {
				this.unlinkFile({filepath: params.outFilePath}, (err) => {
					if (err) {
						let error = {type: 'critical', message: err};
						return callback(error);
					}
					return callback(null, params);
				});
			}
		],
		(err, result) => onDone(err, result));
	}

	prepareDataFormatToSave (inParams) {
		let buffer;
		if (inParams.type === 'string')
			buffer = Buffer.from(inParams.data, 'utf16le');
		if (inParams.type === 'int') {
			buffer = Buffer.from(new Array(4));
			buffer.writeInt32LE(inParams.data, 0);
		}
		if (inParams.type === 'float') {
			buffer = Buffer.from(new Array(4));
			buffer.writeFloatLE(inParams.data, 0);
		}
		return buffer;
	}

	formTrueCheckAnswer (inParams) {
		let answer = Object.assign({}, inParams.answer);
		answer.Check_Result.IsDuplicate = true;
		answer.Check_Result.Probability = inParams.result.probability * 100;
		answer.Check_Result.Algorithm = inParams.Algorithm;
		answer.Check_Result.DuplicateFileName = inParams.categoryPath;
		let foundedWordsString;
		inParams.result.foundedWords.forEach((word) => {
			if (foundedWordsString === undefined)
				foundedWordsString = word + ';';
			else
				foundedWordsString += word + ';';
		});
		answer.Check_Result.FoundedWords = foundedWordsString;
		let logString = /* zres:z_cs_category */'Категория '/* /zres */ + inParams.tempCatalog + /* zres:z_cs_probability */' с вероятностью: '/* /zres */ + (inParams.result.probability * 100).toString() + /* zres:z_cs_found_words */' найденные слова: '/* /zres */;
		inParams.result.foundedWords.forEach((word) => {
			logString += word + ',';
		});
		logString = logString.toString('utf16le');
		let base64logString = Buffer.from(logString).toString('base64');
		answer.log = base64logString;
		return answer;
	}
}

module.exports = Trainer;
