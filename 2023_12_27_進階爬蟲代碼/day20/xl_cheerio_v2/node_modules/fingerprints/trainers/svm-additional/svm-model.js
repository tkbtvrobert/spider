
const ProblemSVM = require('./svm-problem.js');
const SvmKernel = require('./svm-kernel-svc.js');
const SvmSolver = require('./svm-solver.js');

class ModelSVM {
	constructor (inParams) {
		this.params = inParams;
	}

	train (inParams) {
	//	console.log('1');
		let l = inParams.svmProblem.l;
		let svmData = this._getSvmGroupClasses(inParams);
		if (svmData.nr_class === 1)
			console.log('WARNING: training data in only one class');
		let x = [];
		for (let i = 0; i < l; i++)
			x[i] = inParams.svmProblem.x[svmData.perm[i]];
		let weightedC = [];
		for (let i = 0; i < svmData.nr_class; i++)
			weightedC.push(this.params.C);
		let nonzero = [];
		for (let i = 0; i < l; i++)
			nonzero[i] = false;
		let decisionFunction = [];
		let _probA = [];
		let _probB = [];
		let p = 0;
		for (let i = 0; i < svmData.nr_class; i++) {
			for (let j = i + 1; j < svmData.nr_class; j++) {
				let subProb = new ProblemSVM();
				let si = svmData.start[i];
				let sj = svmData.start[j];
				let ci = svmData.count[i];
				let cj = svmData.count[j];
				subProb.l = ci + cj;
				for (let k = 0; k < ci; k++) {
					subProb.x[k] = x[si + k];
					subProb.y[k] = 1;
				}

				for (let k = 0; k < cj; k++) {
					subProb.x[ci + k] = x[sj + k];
					subProb.y[ci + k] = -1;
				}
				//	console.log(subProb);
				//	console.log('PROBAB ' + this.params.probability)
				if (this.params.probability) {
				//	console.log('CALCULATING PROBS')
					let binarySvcProbability = this._calculateSvmBinarySvcProbability({prob: subProb, Cp: weightedC[i], Cn: weightedC[j]});
					//	console.log('___________there');
					//	console.log(binarySvcProbability);
					_probA[0] = binarySvcProbability.fixedA;
					_probB[0] = binarySvcProbability.fixedB;
				}

				decisionFunction[p] = this._trainOneSvm({subProb: subProb, Cp: weightedC[i], Cn: weightedC[j]});
				// console.log(decisionFunction[p]);
				for (let k = 0; k < ci; k++) {
					if (!nonzero[si + k] && Math.abs(decisionFunction[p].alpha[k]) > 0)
						nonzero[si + k] = true;
				}

				for (let k = 0; k < cj; k++) {
					if (!nonzero[sj + k] && Math.abs(decisionFunction[p].alpha[ci + k]) > 0)
						nonzero[sj + k] = true;
				}
				++p;
			}
		}

		//		console.log(decisionFunction);
		//	console.log(_probA);
		//	console.log('&&&');
		//	console.log(_probB);
		//	console.log('&&&');
		this.params.Num_Classes = svmData.nr_class;
		this.params.labels_Of_Classes = [];

		for (let i = 0; i < svmData.nr_class; i++)
			this.params.labels_Of_Classes[i] = svmData.label[i];

		this.params.rho = [];

		for (let i = 0; i < svmData.nr_class * (svmData.nr_class - 1) / 2; i++)
			this.params.rho[i] = decisionFunction[i].rho;
		this.params.probA = [];
		this.params.probB = [];
		console.log('PROBSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS')
		console.log(_probA);
		console.log('PROBSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS')
		console.log(_probB)
		if (this.params.probability) {
			this.params.probA = _probA[0];
			this.params.probB = _probB[0];
		}

		let totalSv = 0;
		let nzCount = [];
		this.params.num_SV_For_Classes = [];
		for (let i = 0; i < svmData.nr_class; i++) {
			let nSV = 0;
			for (let j = 0; j < svmData.count[i]; j++) {
				if (nonzero[svmData.start[i] + j]) {
					++nSV;
					++totalSv;
				}
			}
			this.params.num_SV_For_Classes[i] = nSV;
			nzCount[i] = nSV;
		}
		this.params.num_SV = totalSv;

		this.params.SV = [];
		p = 0;
		for (let i = 0; i < l; i++) {
			if (nonzero[i])
				this.params.SV[p++] = x[i];
		}

		let nzStart = [];
		nzStart[0] = 0;
		for (let i = 1; i < svmData.nr_class; i++)
			nzStart[i] = nzStart[i - 1] + nzCount[i - 1];

		this.params.sv_coef = [];
		for (let i = 0; i < svmData.nr_class - 1; i++)
			this.params.sv_coef[i] = {total: totalSv, coefs: []};

		p = 0;
		for (let i = 0; i < svmData.nr_class; i++) {
			for (let j = i + 1; j < svmData.nr_class; j++) {
				let si = svmData.start[i];
				let sj = svmData.start[j];
				let ci = svmData.count[i];
				let cj = svmData.count[j];
				let q = nzStart[i];
				for (let k = 0; k < ci; k++) {
					if (nonzero[si + k])
						this.params.sv_coef[j - 1].coefs[q++] = decisionFunction[p].alpha[k];
				}
				q = nzStart[j];
				for (let k = 0; k < cj; k++) {
					if (nonzero[sj + k])
						this.params.sv_coef[i].coefs[q++] = decisionFunction[p].alpha[ci + k];
				}
				++p;
			}
		}
		console.log('__________________________________________FINISH EXECUTE');
	//	console.log(this);
	}

	_getSvmGroupClasses (inParams) {
		let l = inParams.svmProblem.l;
		let nrClass = 0;
		let label = [];
		let count = [];
		let dataLabel = [];
		let perm = [];
		for (let i = 0; i < l; i++) {
			let thisLabel = inParams.svmProblem.y[i];
			let j;
			for (j = 0; j < nrClass; j++) {
				if (thisLabel === label[j]) {
					++count[j];
					break;
				}
			}
			dataLabel[i] = j;
			if (j === nrClass) {
				label[nrClass] = thisLabel;
				count[nrClass] = 1;
				++nrClass;
			}
		}
		let start = [];
		start[0] = 0;
		for (let i = 1; i < nrClass; i++)
			start[i] = start[i - 1] + count[i - 1];
		for (let i = 0; i < l; i++) {
			perm[start[dataLabel[i]]] = i;
			++start[dataLabel[i]];
		}
		start[0] = 0;
		for (let i = 1; i < nrClass; i++)
			start[i] = start[i - 1] + count[i - 1];
		let answer = {
			perm: perm,
			label: label,
			nr_class: nrClass,
			start: start,
			count: count
		};
		return answer;
	}

	_calculateSvmBinarySvcProbability (inParams) {
		let nrFold = 5;
		let perm = [];
		let decValues = [];

		for (let i = 0; i < inParams.prob.l; i++)
			perm[i] = i;
		for (let i = 0; i < inParams.prob.l; i++) {
			let j = i + Math.floor(Math.random() * (inParams.prob.l - i)); // Math.random() % (inParams.prob.l - i);
			let temp = perm[i];
			perm[i] = perm[j];
			perm[j] = temp;
		}
		//	console.log('---CNTRL BREAK -1')
		//	console.log(perm);
		for (let i = 0; i < nrFold; i++) {
			let begin = i * inParams.prob.l / nrFold;
			let end = (i + 1) * inParams.prob.l / nrFold;
			// console.log('BEGIN ' + begin)
			// console.log('END ' + end)
			let subProb = new ProblemSVM();
			let j;
			subProb.l = inParams.prob.l - (end - begin);
			subProb.x = [];
			subProb.y = [];
			let k = 0;
			for (j = 0; j < begin; j++) {
				subProb.x[k] = inParams.prob.x[perm[j]];
				subProb.y[k] = inParams.prob.y[perm[j]];
				++k;
			}
			for (j = end; j < inParams.prob.l; j++) {
				subProb.x[k] = inParams.prob.x[perm[j]];
				subProb.y[k] = inParams.prob.y[perm[j]];
				++k;
			}
			let pCount = 0;
			let nCount = 0;
			for (j = 0; j < k; j++) {
				if (subProb.y[j] > 0)
					pCount++;
				else
					nCount++;
			}

			if (pCount === 0 && nCount === 0) {
				for (j = begin; j < end; j++)
					decValues[perm[j]] = 0;
			} else if (pCount > 0 && nCount === 0) {
				for (j = begin; j < end; j++)
					decValues[perm[j]] = 1;
			} else if (pCount === 0 && nCount > 0) {
				for (j = begin; j < end; j++)
					decValues[perm[j]] = -1;
			} else {
			//	console.log('there ' + pCount + '    ' + nCount);
				let submodel = new ModelSVM(this.params);
				// console.log(submodel.params);
				submodel.params.probability = false;
				submodel.params.C = 1.0;
				submodel.params.weight_label[0] = 1;
				submodel.params.weight_label[1] = -1;
				submodel.params.weight[0] = 1.0;
				submodel.params.weight[1] = 1.0;
				//	console.log('TRAIN NEW MODEL')
				submodel.train({svmProblem: subProb});
				for (j = begin; j < end; j++) {
					let predicat = submodel.predictValues({x: inParams.prob.x[perm[j]]});
					//		console.log('_PRED')
					//		console.log('PERM J ' + perm[j]);
					//		console.log(predicat);
					decValues[perm[j]] = predicat.dec_values[0] * submodel.params.labels_Of_Classes[0];
				//	decValues[perm[j]] = 666;
				}
			}
		}
		console.log('_____DEC ' + decValues);
		//	console.log('---CNTRL BREAK 1')
		//	console.log('l ' + inParams.prob.l + ' decVal '+ decValues + ' Labels ' + inParams.prob.y);
		let answer = this._sigmoidTrain({l: inParams.prob.l, dec_values: decValues, labels: inParams.prob.y});
		console.log('_________________')
		console.log(answer);
		return answer;
	}

	_sigmoidTrain (inParams) {
		// console.log('SIGMOID');
		// console.log(inParams);
		let prior1 = 0;
		let prior0 = 0;

		for (let i = 0; i < inParams.l; i++) {
			if (inParams.labels[i] > 0)
				prior1 += 1;
			else
				prior0 += 1;
		}

		let maxIter = 100;
		let minStep = 1e-10;
		let sigma = 1e-12;
		let eps = 1e-5;
		let hiTarget = (prior1 + 1.0) / (prior1 + 2.0);
		let loTarget = 1 / (prior0 + 2.0);
		let t = [];
		let fApB, p, q, h11, h22, h21, g1, g2, det, dA, dB, gd, stepsize, newA, newB, newf, d1, d2, iter;
		let basedA = 0;
		let basedB = Math.log((prior0 + 1.0) / (prior1 + 1.0));
		let fval = 0.0;

		for (let i = 0; i < inParams.l; i++) {
			if (inParams.labels[i] > 0)
				t[i] = hiTarget;
			else
				t[i] = loTarget;
			fApB = inParams.dec_values[i] * basedA + basedB;
			if (fApB >= 0)
				fval += t[i] * fApB + Math.log(1 + Math.exp(-fApB));
			else
				fval += (t[i] - 1) * fApB + Math.log(1 + Math.exp(fApB));
		}
		for (iter = 0; iter < maxIter; iter++) {
			h11 = sigma;
			h22 = sigma;
			h21 = 0.0;
			g1 = 0.0;
			g2 = 0.0;
			for (let i = 0; i < inParams.l; i++) {
				fApB = inParams.dec_values[i] * basedA + basedB;
				if (fApB >= 0) {
					p = Math.exp(-fApB) / (1.0 + Math.exp(-fApB));
					q = 1.0 / (1.0 + Math.exp(-fApB));
				} else {
					p = 1.0 / (1.0 + Math.exp(fApB));
					q = Math.exp(fApB) / (1.0 + Math.exp(fApB));
				}
				d2 = p * q;
				h11 += inParams.dec_values[i] * inParams.dec_values[i] * d2;
				h22 += d2;
				h21 += inParams.dec_values[i] * d2;
				d1 = t[i] - p;
				g1 += inParams.dec_values[i] * d1;
				g2 += d1;
			}

			if (Math.abs(g1) < eps && Math.abs(g2) < eps)
				break;

			det = h11 * h22 - h21 * h21;
			dA = -(h22 * g1 - h21 * g2) / det;
			dB = -(-h21 * g1 + h11 * g2) / det;
			gd = g1 * dA + g2 * dB;

			stepsize = 1;
			while (stepsize >= minStep) {
				newA = basedA + stepsize * dA;
				newB = basedB + stepsize * dB;
				newf = 0.0;
				for (let i = 0; i < inParams.l; i++) {
					fApB = inParams.dec_values[i] * newA + newB;
					if (fApB >= 0)
						newf += t[i] * fApB + Math.log(1 + Math.exp(-fApB));
					else
						newf += (t[i] - 1) * fApB + Math.log(1 + Math.exp(fApB));
				}

				if (newf < fval + 0.0001 * stepsize * gd) {
					basedA = newA;
					basedB = newB;
					fval = newf;
					break;
				} else {
					stepsize = stepsize / 2.0;
				}
			}

			if (stepsize < minStep) {
				console.log('Line search fails in two-class probability estimates');
				break;
			}
		}
		if (iter >= maxIter)
			console.log(':Reaching maximal iterations in two-class probability estimates\n');
		console.log('probs' + basedA + '   ' + basedB);
		return {fixedA: basedA, fixedB: basedB};
	}

	_trainOneSvm (inParams) {
		let alpha = [];
		let si = {
			obj: null,
			rho: null,
			upper_bound_p: null,
			upper_bound_n: null
		};

		let l = inParams.subProb.l;
		let minusOnes = [];
		let y = [];

		for (let i = 0; i < l; i++) {
			alpha[i] = 0;
			minusOnes[i] = -1;
			if (inParams.subProb.y[i] > 0)
				y[i] = 1;
			else
				y[i] = -1;
		}
		let Kernel = new SvmKernel({params: this.params, prob: inParams.subProb, y: y});
		let solveParams = {
			l: l,
			kernel: Kernel,
			minus_ones: minusOnes,
			y: y,
			alpha: alpha,
			Cp: inParams.Cp,
			Cn: inParams.Cn,
			eps: this.params.eps,
			si: si,
			shrinking: this.params.shrinking
		};

		let svcSvmSolver = new SvmSolver();
		let solved = svcSvmSolver.solve(solveParams);
		alpha = solved.alpha;
		//	console.log('################# ' + alpha + ' ####### ' + si.rho)
		return {alpha: alpha, rho: si.rho};
	}

	predictValues (inParams) {
		let decValues = [];
		let nrClass = this.params.Num_Classes;
		let kvalue = [];

		for (let i = 0; i < this.params.num_SV; i++) {
			if (this.params.SV[i] !== undefined)
				kvalue[i] = this._kernelFunction({x: inParams.x, y: this.params.SV[i]});
		}

		//	console.log(this)
		//	console.log(this.params.SV)
		//	console.log('##')
		//	console.log(kvalue);
		let start = [];
		let vote = [];
		start[0] = 0;
		for (let i = 1; i < nrClass; i++) {
			start[i] = start[i - 1] + this.params.num_SV_For_Classes[i - 1];
			vote[i] = 0;
		}
		// console.log(start);
		// console.log(this.params)
		let p = 0;
		for (let i = 0; i < nrClass; i++) {
			for (let j = i + 1; j < nrClass; j++) {
				let sum = 0;
				let si = start[i];
				let sj = start[j];
				let ci = this.params.num_SV_For_Classes[i];
				let cj = this.params.num_SV_For_Classes[j];
				let k;
				let coef1 = this.params.sv_coef[j - 1]; // ???
				let coef2 = this.params.sv_coef[i];
				// console.log('COEF')
				// console.log(coef2);
				for (k = 0; k < ci; k++) {
					let temp = coef1.coefs[si + k] * kvalue[si + k];
					sum += temp;
				}
				// console.log('_SUM ' + sum)
				for (k = 0; k < cj; k++) {
					// console.log('coef2.coefs[' + sj + ' '+ k + '] = ' + coef2.coefs[si + k])
					// console.log(kvalue[sj + k])

					let tt1 = sj + k;
					// console.log('TT!_________________' + tt1)
					// console.log( coef2.coefs[tt1])
					let temp = coef2.coefs[sj + k] * kvalue[sj + k];
					// console.log('temp__' + temp)
					sum += temp;
				}
				// console.log('_SUM_2 ' + sum)
				sum -= this.params.rho[p];
				decValues[p] = sum;

				if (decValues[p] > 0)
					++vote[i];
				else
					++vote[j];
				p++;
			}
		}
		return ({dec_values: decValues});
		/*
		let voteMaxIdx = 0;
		for (let i = 1; i < nr_class; i++) {
			if (vote[i] > vote[voteMaxIdx])
				vote_max_idx = i;
		}
        */
		// return labels_Of_Classes[vote_max_idx];
	}

	_kernelFunction (inParams) { // (x, SV[i], param); //(const ZInd_SVL_Node *x, const ZInd_SVL_Node *y, const ZInd_SVL_Params& param)
		let sum = 0;
		let xIter = 0;
		let yIter = 0;
		while (inParams.x.internal[xIter].coord !== -1 && inParams.y.internal[yIter].coord !== -1) {
			if (inParams.x.internal[xIter].coord === inParams.y.internal[yIter].coord) {
				let d = inParams.x.internal[xIter].value - inParams.y.internal[yIter].value;
				sum += d * d;
				++xIter;
				++yIter;
			} else {
				if (inParams.x.internal[xIter].coord > inParams.y.internal[yIter].coord) {
					sum += inParams.y.internal[yIter].value * inParams.y.internal[yIter].value;
					++yIter;
				} else {
					sum += inParams.x.internal[xIter].value * inParams.x.internal[xIter].value;
					++xIter;
				}
			}
		}

		while (inParams.x.internal[xIter].coord !== -1) {
			sum += inParams.x.internal[xIter].value * inParams.x.internal[xIter].value;
			++xIter;
		}

		while (inParams.y.internal[yIter].coord !== -1) {
			sum += inParams.y.internal[yIter].value * inParams.y.internal[yIter].value;
			++yIter;
		}

		return Math.exp(-this.params.gamma * sum);
	}
}
module.exports = ModelSVM;
