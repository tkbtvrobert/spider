class SVCQ {
	constructor (inParams) {
		this.xSquare = [];
		this.degree = inParams.params.degree;
		this.gamma = inParams.params.gamma;
		this.coef0 = inParams.params.coef0;
		this.x = inParams.prob.x;
		this.y = inParams.y;
		for (let i = 0; i < inParams.prob.l; i++)
			this.xSquare[i] = this._getDot({iteratorX: i, iteratorY: i});
		this.QD = [];
		for (let i = 0; i < inParams.prob.l; i++)
			this.QD[i] = this._calculateKernelRbf({i: i, j: i});
	}

	_calculateKernelRbf (inParams) {
		return Math.exp((-1 * this.gamma) * (this.xSquare[inParams.i] + this.xSquare[inParams.j] - 2 * this._getDot({iteratorX: inParams.i, iteratorY: inParams.j})));
	}

	_getDot (inParams) {
		let sum = 0;
		let iteratorX = 0;
		let iteratorY = 0;
		// console.log(inParams.iteratorX);
		let px = this.x[inParams.iteratorX].internal[iteratorX];
		let py = this.x[inParams.iteratorY].internal[iteratorY];
		while (px.coord !== -1 && py.coord !== -1) {
			if (px.coord === py.coord) {
				sum += px.value * py.value;
				px = this.x[inParams.iteratorX].internal[iteratorX++];
				py = this.x[inParams.iteratorX].internal[iteratorY++];
			} else {
				if (px.coord > py.coord)
					py = this.x[inParams.iteratorX].internal[iteratorY++];
				else
					px = this.x[inParams.iteratorX].internal[iteratorX++];
			}
		}
		return sum;
	}

	swap (inParams) {
		let temp;
		temp = this.x[inParams.i];
		this.x[inParams.i] = this.x[inParams.j];
		this.x[inParams.j] = temp;

		temp = this.y[inParams.i];
		this.y[inParams.i] = this.y[inParams.j];
		this.y[inParams.j] = temp;
	}

	getQD () {
		return this.QD;
	}

	getQ (inParams) {
		//console.log(inParams)
		// это не точно
		let data = [];
		for (let j = 0; j < inParams.len; j++)
			data[j] = (this.y[inParams.i] * this.y[j] * (this._calculateKernelRbf({i: inParams.i, j: j})));

		return data;
	}
}
module.exports = SVCQ;
