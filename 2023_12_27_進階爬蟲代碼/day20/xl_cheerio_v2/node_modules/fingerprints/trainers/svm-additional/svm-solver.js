
const bounds = {
	LOWER_BOUND: 0,
	UPPER_BOUND: 1,
	FREE: 2
};

class Solver {
	constructor (inParams) {
		this.unshrink = false;
	}

	_updateAlphaStatus (i) {
		// console.log('___ALPHA' + this.alpha[i]);
		if (this.alpha[i] >= this._getC(i))
			this.alpha_status[i] = bounds.UPPER_BOUND;
		else if (this.alpha[i] <= 0)
			this.alpha_status[i] = bounds.LOWER_BOUND;
		else
			this.alpha_status[i] = bounds.FREE;
	}

	_isUpperBound (i) {
		// console.log('UPPER ' + this.alpha_status[i]);
		return this.alpha_status[i] === bounds.UPPER_BOUND;
	}

	_isLowerBound (i) {
		return this.alpha_status[i] === bounds.LOWER_BOUND;
	}

	_isFree (i) {
		return this.alpha_status[i] === bounds.FREE;
	}

	_max (a, b) {
		return (((a) > (b)) ? (a) : (b));
	}

	_min (a, b) {
		return (((a) < (b)) ? (a) : (b));
	}

	_selectWorkingSet (inParams) {
		let Gmax = -Infinity;
		let Gmax2 = -Infinity;
		let GmaxIdx = -1;
		let GminIdx = -1;
		let objDiffMin = Infinity;

		for (let t = 0; t < this.active_size; t++) {
			if (this.y[t] === 1) {
				if (!this._isUpperBound(t)) {
					if ((-1 * this.G[t]) >= Gmax) {
						Gmax = -1 * this.G[t];
						GmaxIdx = t;
					}
				}
			} else {
				if (!this._isLowerBound(t)) {
					if (this.G[t] >= Gmax) {
						Gmax = this.G[t];
						GmaxIdx = t;
					}
				}
			}
		}
		let i = GmaxIdx;
		let Qi = null;
		if (i !== -1)
			Qi = this.Q.getQ({i: i, len: this.active_size});

		for (let j = 0; j < this.active_size; j++) {
			if (this.y[j] === 1) {
				if (!this._isUpperBound(j)) {
					let gradDiff = Gmax + this.G[j];
					if (this.G[j] >= Gmax2)
						Gmax2 = this.G[j];
					if (gradDiff > 0) {
						let objDiff;
						let quadCoef = this.QD[i] + this.QD[j] - 2.0 * this.y[i] * Qi[j];
						if (quadCoef > 0)
							objDiff = -1 * ((gradDiff * gradDiff) / quadCoef);
						else
							objDiff = -1 * ((gradDiff * gradDiff) / 0.000000000001);

						if (objDiff <= objDiffMin) {
							GminIdx = j;
							objDiffMin = objDiff;
						}
					}
				}
			} else {
				if (!this._isUpperBound(j)) {
					let gradDiff = Gmax - this.G[j];
					if (-1 * this.G[j] >= Gmax2)
						Gmax2 = -1 * this.G[j];
					if (gradDiff > 0) {
						let objDiff;
						let quadCoef = this.QD[i] + this.QD[j] + 2.0 * this.y[i] * Qi[j];
						if (quadCoef > 0)
							objDiff = -(gradDiff * gradDiff) / quadCoef;
						else
							objDiff = -(gradDiff * gradDiff) / 0.000000000001;

						if (objDiff <= objDiffMin) {
							GminIdx = j;
							objDiffMin = objDiff;
						}
					}
				}
			}
		}
		// ('Gmax1 ' + Gmax + ' Gmax2 ' + Gmax2 + ' eps ' + this.eps)
		// console.log('GmaxIdx ' + GmaxIdx + ' GminIdx ' + GminIdx)
		if (Gmax + Gmax2 < this.eps)
			return true;

		inParams.toOut.i = GmaxIdx;
		inParams.toOut.j = GminIdx;
		return false;
	}

	_reconstructGradient () {
		if (this.active_size === this.l)
			return;
		let i, j;
		let nrFree = 0;
		for (j = this.active_size; j < this.l; j++)
			this.G[j] = this.G_bar[j] + this.p[j];
		for (j = 0; j < this.active_size; j++) {
			if (this._isFree(j))
				nrFree++;
		}
		if (2 * nrFree < this.active_size)
			console.log('WARNING: using -h 0 may be faster');
		if (nrFree * this.l > 2 * this.active_size * (this.l - this.active_size)) {
			for (i = this.active_size; i < this.l; i++) {
				let Qi = this.Q.getQ({i: i, len: this.active_size});
				for (j = 0; j < this.active_size; j++) {
					if (this._isFree(j))
						this.G[i] += this.alpha[j] * Qi[j];
				}
			}
		} else {
			for (i = 0; i < this.active_size; i++) {
				if (this._isFree(i)) {
					let Qi = this.Q.getQ({i: i, len: this.l});
					let alphaI = this.alpha[i];
					for (j = this.active_size; j < this.l; j++)
						this.G[j] += alphaI * Qi[j];
				}
			}
		}
	}

	_getC (i) {
		return (this.y[i] > 0) ? this.Cp : this.Cn;
	}

	_calculateRho () {
		let r;
		let nrFree = 0;
		let ub = Infinity;
		let lb = -Infinity;
		let sumFree = 0;
		for (let i = 0; i < this.active_size; i++) {
			let yG = this.y[i] * this.G[i];

			if (this._isUpperBound(i)) {
				if (this.y[i] === -1)
					ub = this._min(ub, yG);
				else
					lb = this._max(lb, yG);
			} else if (this._isLowerBound(i)) {
				if (this.y[i] === 1)
					ub = this._min(ub, yG);
				else
					lb = this._max(lb, yG);
			} else {
				++nrFree;
				sumFree += yG;
			}
		}
		// console.log('SUMFREE ' + sumFree + ' NRFREE ' + nrFree + ub + lb);
		if (nrFree > 0)
			r = sumFree / nrFree;
		else
			r = (ub + lb) / 2;
		return r;
	}

	_doShrinking () {
		let Gmax1 = -Infinity;
		let Gmax2 = -Infinity;
		for (let i = 0; i < this.active_size; i++) {
			if (this.y[i] === 1) {
				if (!this._isUpperBound(i)) {
					if (-1 * this.G[i] >= Gmax1)
						Gmax1 = -1 * this.G[i];
				}
				if (!this._isLowerBound(i)) {
					if (this.G[i] >= Gmax2)
						Gmax2 = this.G[i];
				}
			} else {
				if (!this._isUpperBound(i)) {
					if (-1 * this.G[i] >= Gmax2)
						Gmax2 = -1 * this.G[i];
				}
				if (!this._isLowerBound(i)) {
					if (this.G[i] >= Gmax1)
						Gmax1 = this.G[i];
				}
			}
		}

		if (this.unshrink === false && Gmax1 + Gmax2 <= this.eps * 10) {
			this.unshrink = true;
			this._reconstructGradient();
			this.active_size = this.l;
		}

		for (let i = 0; i < this.active_size; i++) {
			if (this._checkShrunk({i: i, Gmax1: Gmax1, Gmax2: Gmax2})) {
				this.active_size--;
				while (this.active_size > i) {
					if (this._checkShrunk({i: this.active_size, Gmax1: Gmax1, Gmax2: Gmax2})) {
						this._swapIndex(i, this.active_size);
						break;
					}
					this.active_size--;
				}
			}
		}
	}

	_swapIndex (i, j) {
		let temp;

		this.Q.swap({i: i, j: j});
		// Q->swap_index(i,j);
		temp = this.y[i];
		this.y[i] = this.y[j];
		this.y[j] = temp;

		temp = this.G[i];
		this.G[i] = this.G[j];
		this.G[j] = temp;

		temp = this.alpha_status[i];
		this.alpha_status[i] = this.alpha_status[j];
		this.alpha_status[j] = temp;

		temp = this.alpha[i];
		this.alpha[i] = this.alpha[j];
		this.alpha[j] = temp;

		temp = this.p[i];
		this.p[i] = this.p[j];
		this.p[j] = temp;

		temp = this.active_set[i];
		this.active_set[i] = this.active_set[j];
		this.active_set[j] = temp;

		temp = this.G_bar[i];
		this.G_bar[i] = this.G_bar[j];
		this.G_bar[j] = temp;
	}

	_checkShrunk (inParams) {
		if (this._isUpperBound(inParams.i)) {
			if (this.y[inParams.i] === 1)
				return (-1 * this.G[inParams.i] > inParams.Gmax1);
			else
				return (-1 * this.G[inParams.i] > inParams.Gmax2);
		} else if (this._isLowerBound(inParams.i)) {
			if (this.y[inParams.i] === 1)
				return (this.G[inParams.i] > inParams.Gmax2);
			else
				return (this.G[inParams.i] > inParams.Gmax1);
		} else {
			return (false);
		}
	}

	solve (inParams) {
		this.l = inParams.l;
		this.Q = inParams.kernel;
		this.QD = this.Q.getQD();
		this.p = inParams.minus_ones;
		this.y = inParams.y;
		this.alpha = inParams.alpha;
		// console.log(inParams.alpha);
		this.Cp = inParams.Cp;
		this.Cn = inParams.Cn;
		this.eps = inParams.eps;
		this.alpha_status = [];
		this.active_set = [];
		for (let i = 0; i < this.l; i++) {
			this.active_set[i] = i;
			this._updateAlphaStatus(i);
		}

		this.active_size = this.l;

		this.G = [];
		this.G_bar = [];

		for (let i = 0; i < this.l; i++) {
			this.G[i] = this.p[i];
			this.G_bar[i] = 0;
		}

		for (let i = 0; i < this.l; i++) {
			if (!this._isLowerBound(i)) {
				let Qi = this.Q.getQ({i: i, len: this.l});
				let alphaI = this.alpha[i];
				for (let j = 0; j < this.l; j++)
					this.G[j] += alphaI * Qi[j];
				if (this._isUpperBound(i)) {
					for (let j = 0; j < this.l; j++)
						this.G_bar[j] += this._getC(i) * Qi[j];
				}
			}
		}
		let iter = 0;
		let maxIter = this._max(10000000, this.l > 2147483647 / 100 ? 2147483647 : 100 * this.l);
		let counter = this._min(this.l, 1000) + 1;
		// maxIter = 10000;
		// console.log(iter + '  ' + maxIter);
		const iterators = {i: undefined, y: undefined};

		while (iter < maxIter) {
			// console.log('ITERRRRR ');

			if (--counter === 0) {
				counter = this._min(this.l, 1000);
				if (inParams.shrinking)
					this._doShrinking();
			}
			// let outObj = this._selectWorkingSet({toOut: iterators});
			// console.log(outObj)
			// let i = outObj.out_i;
			// let j = outObj.out_j;
			if (this._selectWorkingSet({toOut: iterators})) {
				this._reconstructGradient();
				this.active_size = this.l;
				// outObj = this._selectWorkingSet();
				// console.log(outObj);
				// i = outObj.out_i;
				// j = outObj.out_j;
				if (this._selectWorkingSet({toOut: iterators}))
					break;
				else
					counter = 1;
			}
			++iter;
			let Qi = this.Q.getQ({i: iterators.i, len: this.active_size});
			let Qj = this.Q.getQ({i: iterators.j, len: this.active_size});
			let Ci = this._getC(iterators.i);
			let Cj = this._getC(iterators.j);

			let oldAlphaI = this.alpha[iterators.i];
			let oldAlphaJ = this.alpha[iterators.j];

			if (this.y[iterators.i] !== this.y[iterators.j]) {
				let quadCoef = this.QD[iterators.i] + this.QD[iterators.j] + 2 * Qi[iterators.j];
				if (quadCoef <= 0)
					quadCoef = 0.000000000001;
				let delta = (-1 * this.G[iterators.i] - this.G[iterators.j]) / quadCoef;
				let diff = this.alpha[iterators.i] - this.alpha[iterators.j];
				this.alpha[iterators.i] += delta;
				this.alpha[iterators.j] += delta;
				if (diff > 0) {
					if (this.alpha[iterators.j] < 0) {
						this.alpha[iterators.j] = 0;
						this.alpha[iterators.i] = diff;
					}
				} else {
					if (this.alpha[iterators.i] < 0) {
						this.alpha[iterators.i] = 0;
						this.alpha[iterators.j] = -1 * diff;
					}
				}
				if (diff > Ci - Cj) {
					if (this.alpha[iterators.i] > Ci) {
						this.alpha[iterators.i] = Ci;
						this.alpha[iterators.j] = Ci - diff;
					}
				} else {
					if (this.alpha[iterators.j] > Cj) {
						this.alpha[iterators.j] = Cj;
						this.alpha[iterators.i] = Cj + diff;
					}
				}
			} else {
				let quadCoef = this.QD[iterators.i] + this.QD[iterators.j] - 2 * Qi[iterators.j];
				if (quadCoef <= 0)
					quadCoef = 0.000000000001; ;
				let delta = (this.G[iterators.i] - this.G[iterators.j]) / quadCoef;
				let sum = this.alpha[iterators.i] + this.alpha[iterators.j];
				this.alpha[iterators.i] -= delta;
				this.alpha[iterators.j] += delta;

				if (sum > Ci) {
					if (this.alpha[iterators.i] > Ci) {
						this.alpha[iterators.i] = Ci;
						this.alpha[iterators.j] = sum - Ci;
					}
				} else {
					if (this.alpha[iterators.j] < 0) {
						this.alpha[iterators.j] = 0;
						this.alpha[iterators.i] = sum;
					}
				}
				if (sum > Cj) {
					if (this.alpha[iterators.j] > Cj) {
						this.alpha[iterators.j] = Cj;
						this.alpha[iterators.i] = sum - Cj;
					}
				} else {
					if (this.alpha[iterators.i] < 0) {
						this.alpha[iterators.i] = 0;
						this.alpha[iterators.j] = sum;
					}
				}
			}
			let deltaAlphaI = this.alpha[iterators.i] - oldAlphaI;
			let deltaAlphaJ = this.alpha[iterators.j] - oldAlphaJ;

			for (let k = 0; k < this.active_size; k++)
				this.G[k] += Qi[k] * deltaAlphaI + Qj[k] * deltaAlphaJ;

			let ui = this._isUpperBound(iterators.i);
			let uj = this._isUpperBound(iterators.j);
			this._updateAlphaStatus(iterators.i);
			this._updateAlphaStatus(iterators.j);
			if (ui !== this._isUpperBound(iterators.i)) {
				Qi = this.Q.getQ({i: iterators.i, len: this.l});

				if (ui) {
					for (let k = 0; k < this.l; k++)
						this.G_bar[k] -= Ci * Qi[k];
				} else {
					for (let k = 0; k < this.l; k++)
						this.G_bar[k] += Ci * Qi[k];
				}
			}

			if (uj !== this._isUpperBound(iterators.j)) {
				Qj = this.Q.getQ({i: iterators.j, len: this.l});
				if (uj) {
					for (let k = 0; k < this.l; k++)
						this.G_bar[k] -= Cj * Qj[k];
				} else {
					for (let k = 0; k < this.l; k++)
						this.G_bar[k] += Cj * Qj[k];
				}
			}
		}

		if (iter >= maxIter) {
			if (this.active_size < this.l) {
				this._reconstructGradient();
				this.active_size = this.l;
			}
			console.log('WARNING: reaching max number of iterations');
		}

		inParams.si.rho = this._calculateRho();
		let v = 0;

		for (let i = 0; i < this.l; i++)
			v += this.alpha[i] * (this.G[i] + this.p[i]);

		inParams.si.obj = v / 2;
		let returnAlpha = inParams.alpha;
		for (let i = 0; i < this.l; i++)
			returnAlpha[this.active_set[i]] = this.alpha[i];

		inParams.si.upper_bound_p = this.Cp;
		inParams.si.upper_bound_n = this.Cn;

		return ({alpha: returnAlpha});
	}
}
module.exports = Solver;
