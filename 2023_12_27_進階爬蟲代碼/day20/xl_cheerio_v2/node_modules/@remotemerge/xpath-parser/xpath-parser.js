class l {
  constructor(t) {
    if (this.options = {
      queryFirst: !1
    }, t instanceof Node)
      this.domContent = t;
    else {
      const e = new DOMParser();
      this.domContent = e.parseFromString(t, "text/html");
    }
  }
  evaluate(t) {
    return document.evaluate(
      t,
      this.domContent,
      null,
      this.options.queryFirst ? XPathResult.FIRST_ORDERED_NODE_TYPE : XPathResult.ORDERED_NODE_ITERATOR_TYPE,
      null
    );
  }
  getValue(t) {
    let e = "";
    return t instanceof Attr ? e = t.value || "" : t instanceof HTMLElement && (e = t.textContent || ""), e.trim();
  }
  queryFirst(t) {
    this.options.queryFirst = !0;
    const e = this.evaluate(t);
    return this.getValue(e.singleNodeValue);
  }
  queryList(t) {
    const e = [], r = this.evaluate(t);
    let s;
    for (; s = r.iterateNext(); ) {
      const a = this.getValue(s);
      e.push(a);
    }
    return e;
  }
  multiQuery(t) {
    const e = {};
    return Object.keys(t).forEach((r) => {
      e[r] = this.queryFirst(t[r]);
    }), e;
  }
  subQuery(t = {
    root: "/html",
    pagination: "",
    queries: {}
  }) {
    const e = this.evaluate(t.root), r = [];
    let s = null;
    for (; s = e.iterateNext(); ) {
      this.domContent = s;
      const n = {};
      Object.keys(t.queries).forEach((i) => {
        n[i] = this.queryFirst(t.queries[i]);
      }), r.push(n);
    }
    const a = { results: r };
    return t.pagination && Object.assign(a, {
      paginationUrl: this.queryFirst(t.pagination)
    }), a;
  }
  waitXPath(t, e = 10) {
    let r = 1;
    return new Promise((s, a) => {
      const n = setInterval(() => {
        const i = this.queryFirst(t);
        if (i)
          return clearInterval(n), s({ found: !0, message: i });
        if (r++ >= e) {
          clearInterval(n);
          const o = new Error(`Timeout! Max ${e} seconds are allowed.`);
          return o.name = "TimeoutError", a(o);
        }
      }, 1e3);
    });
  }
}
export {
  l as default
};
